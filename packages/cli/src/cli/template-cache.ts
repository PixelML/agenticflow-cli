/**
 * Local serialization helpers for template bootstrap data.
 */

import { mkdirSync, readFileSync, writeFileSync } from "node:fs";
import { join, resolve } from "node:path";

export const TEMPLATE_CACHE_SCHEMA_VERSION = "agenticflow.templates.cache.v1";
const CACHE_GUIDE_FILE = "HOW_TO_USE.md";
const MANIFEST_FILE = "manifest.json";

export type TemplateKind = "workflow" | "agent" | "workforce";

export interface TemplateDatasetInput {
  kind: TemplateKind;
  operationId: string;
  query: Record<string, string | undefined>;
  items: unknown[];
}

export interface TemplateSyncIssue {
  kind: TemplateKind;
  code: string;
  message: string;
  status?: number;
  hint?: string;
}

export interface TemplateDatasetManifest {
  kind: TemplateKind;
  operation_id: string;
  count: number;
  query: Record<string, string>;
  collection_file: string;
  item_dir: string;
  sample_ids: string[];
}

export interface TemplateCacheManifest {
  schema: string;
  fetched_at: string;
  cache_dir: string;
  docs: {
    web: string;
    mcp: string;
  };
  datasets: TemplateDatasetManifest[];
  issues: TemplateSyncIssue[];
}

function isRecord(value: unknown): value is Record<string, unknown> {
  return typeof value === "object" && value !== null && !Array.isArray(value);
}

function readStringField(record: Record<string, unknown>, ...keys: string[]): string | undefined {
  for (const key of keys) {
    const value = record[key];
    if (typeof value === "string" && value.trim().length > 0) {
      return value.trim();
    }
  }
  return undefined;
}

function sanitizeFileSegment(raw: string, fallback: string): string {
  const trimmed = raw.trim().toLowerCase();
  if (!trimmed) return fallback;
  const sanitized = trimmed
    .replace(/[^a-z0-9]+/g, "-")
    .replace(/^-+/, "")
    .replace(/-+$/, "");
  if (!sanitized) return fallback;
  return sanitized.slice(0, 80);
}

function cleanQuery(query: Record<string, string | undefined>): Record<string, string> {
  const out: Record<string, string> = {};
  for (const [key, value] of Object.entries(query)) {
    if (typeof value === "string" && value.length > 0) out[key] = value;
  }
  return out;
}

function inferTemplateId(item: unknown, index: number): string {
  if (!isRecord(item)) return `item-${index + 1}`;
  return (
    readStringField(
      item,
      "id",
      "uuid",
      "template_id",
      "workflow_template_id",
      "agent_template_id",
      "mas_template_id",
      "wt_id",
    ) ?? `item-${index + 1}`
  );
}

function inferTemplateName(item: unknown, index: number): string {
  if (!isRecord(item)) return `template-${index + 1}`;
  return readStringField(item, "name", "title", "display_name", "slug") ?? `template-${index + 1}`;
}

function buildItemFileName(item: unknown, index: number): string {
  const id = sanitizeFileSegment(inferTemplateId(item, index), `item-${index + 1}`);
  const name = sanitizeFileSegment(inferTemplateName(item, index), "template");
  return `${name}__${id}.json`;
}

function buildCacheGuide(cacheDir: string): string {
  return [
    "# AgenticFlow Template Cache",
    "",
    "This folder is generated by `agenticflow templates sync`.",
    "Use it as local bootstrap context for cold agents before broader docs search.",
    "",
    "Recommended read order:",
    "1. `manifest.json` for counts, source operations, and any sync issues.",
    "2. `*_templates.json` collection files to scan available patterns quickly.",
    "3. `<kind>/` folders for per-template JSON details.",
    "",
    "Refresh command:",
    `- \`agenticflow templates sync --dir ${cacheDir} --json\``,
    "",
    "When local templates are insufficient, continue with:",
    "- https://docs.agenticflow.ai/",
    "- https://docs.agenticflow.ai/~gitbook/mcp",
    "",
  ].join("\n");
}

export function writeTemplateCache(
  outputDir: string,
  datasets: TemplateDatasetInput[],
  issues: TemplateSyncIssue[],
  fetchedAt = new Date().toISOString(),
): TemplateCacheManifest {
  const cacheDir = resolve(outputDir);
  mkdirSync(cacheDir, { recursive: true });

  const manifestDatasets: TemplateDatasetManifest[] = [];

  for (const dataset of datasets) {
    const collectionFile = `${dataset.kind}_templates.json`;
    const kindDir = dataset.kind;
    const collectionPath = join(cacheDir, collectionFile);
    const kindPath = join(cacheDir, kindDir);

    mkdirSync(kindPath, { recursive: true });
    writeFileSync(collectionPath, JSON.stringify(dataset.items, null, 2));

    const sampleIds: string[] = [];
    dataset.items.forEach((item, index) => {
      const itemPath = join(kindPath, buildItemFileName(item, index));
      writeFileSync(itemPath, JSON.stringify(item, null, 2));
      if (sampleIds.length < 5) {
        sampleIds.push(inferTemplateId(item, index));
      }
    });

    manifestDatasets.push({
      kind: dataset.kind,
      operation_id: dataset.operationId,
      count: dataset.items.length,
      query: cleanQuery(dataset.query),
      collection_file: collectionFile,
      item_dir: kindDir,
      sample_ids: sampleIds,
    });
  }

  const manifest: TemplateCacheManifest = {
    schema: TEMPLATE_CACHE_SCHEMA_VERSION,
    fetched_at: fetchedAt,
    cache_dir: cacheDir,
    docs: {
      web: "https://docs.agenticflow.ai/",
      mcp: "https://docs.agenticflow.ai/~gitbook/mcp",
    },
    datasets: manifestDatasets,
    issues,
  };

  writeFileSync(join(cacheDir, MANIFEST_FILE), JSON.stringify(manifest, null, 2));
  writeFileSync(join(cacheDir, CACHE_GUIDE_FILE), buildCacheGuide(cacheDir));
  return manifest;
}

export function readTemplateCacheManifest(outputDir: string): TemplateCacheManifest {
  const cacheDir = resolve(outputDir);
  const manifestPath = join(cacheDir, MANIFEST_FILE);
  const raw = readFileSync(manifestPath, "utf-8");
  const parsed = JSON.parse(raw);
  if (!isRecord(parsed)) {
    throw new Error("Template cache manifest is not an object.");
  }
  return parsed as unknown as TemplateCacheManifest;
}
